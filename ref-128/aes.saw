m <- llvm_load_module "aes.bc";

import "../cryptol-specs/AES.cry";


let allocVal name str  =
      do { let ty = llvm_type str;
           ptr <- crucible_alloc ty;
           val <- crucible_fresh_var name ty;
           crucible_points_to ptr (crucible_term val);
           return (ptr,val);
         };

let {{

// To little endian byte representation
toBytes : {n} (fin n) => [8 * n] -> [n][8]
toBytes bits = reverse (split bits)

fromBytes : {n} (fin n) => [n][8] -> [8 * n]
fromBytes bytes = join (reverse bytes)


// Our algorithm is grouped by rows, but the C one uses columns, hence the 'transpose'
toState : [4][32] -> State
toState cols = transpose [ toBytes col | col <- cols ]

fromState : State -> [4][32]
fromState rows = [ fromBytes col | col <- transpose rows ]

withState : (State -> State) -> [4][32] -> [4][32]
withState f x = fromState (f (toState x))

}};


emulated_aesenc_substitute_bytes <- time (
      crucible_llvm_verify
        m
        "emulated_aesenc_substitute_bytes"
        []
        false
        do { (ptr_data, data) <- allocVal "data" "[4 x i32]";
             crucible_execute_func [ ptr_data ];
             let post = {{ withState sub_bytes data }};
             crucible_points_to ptr_data (crucible_term {{ post }});
             crucible_return (crucible_term {{ 1 : [32] }});
           }
       rme
  );

emulated_aesenc_row_shifting <- time (
  crucible_llvm_verify
    m
    "emulated_aesenc_row_shifting"
    []
    false
    do {
      (ptr_data, data) <- allocVal "data" "[4 x i32]";
      crucible_execute_func [ ptr_data ];
      let post = {{ withState shift_rows data }};
      crucible_points_to ptr_data (crucible_term {{ post }});
      crucible_return (crucible_term {{ 1 : [32] }});
    }
    abc
);


