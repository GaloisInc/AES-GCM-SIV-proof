module Asm128 where

import X86
import AES128
import AES128_GCM_SIV

type AAD_Size = 16
type MSG_Size = 160

dot256 : [256] -> [256] -> [256]
dot256 (_ # res) (_ # h) = 0 # dot res h

Polyval_Horner_def : [16][8] -> [AAD_Size][8] -> [16][8] -> [128]
Polyval_Horner_def h i t = polyvalFrom (leLoad h) (leLoadBlocks i) (leLoad t)

Polyval_Horner_AAD_MSG_def :
  [16][8] -> [AAD_Size][8] -> [MSG_Size][8] -> [2][64] -> [16][8] -> [128]
Polyval_Horner_AAD_MSG_def h aad pt lblk t =
  polyvalFrom (leLoad h) work (leLoad t)
  where
  work = leLoadBlocks aad
       # leLoadBlocks pt
       # leLoadBlocks [ b | qword <- lblk, b <- leStore qword ]

INIT_Htable_post :
  [16][8] -> [128][8] -> Bool
INIT_Htable_post H result =
  INIT_Htable (leLoad H) == (leLoadArray result)


Polyval_HTable_post :
  [AAD_Size][8] -> [128][8] -> [16][8] -> [16][8] -> Bool
Polyval_HTable_post X tbl T result =
  polyvalHtableNH (leLoadArray tbl) (leLoadBlocks X) (leLoad T) == (leLoad result)



// See `derive_key` in the spec.
AES_128_ENC_x4_def : [16][8] -> [11 * 16][8] -> [4 * 128]
AES_128_ENC_x4_def iv' keys =
  leLoad (leStoreArray [ aesWithKeys keys (iv # i) | i <- [ 0 .. 3 ] ])
  where
  _ # (iv : [96]) = leLoad iv'


/* Encrypt the pt with the given key, expanding it as you go.
The result it the encrypted text and the expanded key */
AES_KS_ENC_x1_def1 : [16][8]  -> [11 * 16 * 8]
AES_KS_ENC_x1_def1 ikey =
  leLoad (aesKeyToBytes (ExpandKey (leLoad (reverse ikey))))
  // NOTE: It would appear the key expansion in our spec and the
  // one in the code are reversed.

AES_KS_ENC_x1_def2 : [11 * 16][8] -> [16][8] -> [16 * 8]
AES_KS_ENC_x1_def2 keys pt = aesWithKeys keys (leLoad pt)


ENC_MSG_def :
  [11 * 16][8] -> [16][8] -> [MSG_Size][8] -> [MSG_Size * 8]
ENC_MSG_def keys tag pt =
  leLoad (leStoreBlocks (counter_mode K2 (0b1 # tUpper, tLower) M))
  where
  K2 = aesKeysFromBytes keys
  M  = leLoadBlocks pt
  _ # tUpper # tLower = leLoad tag



ENC_MSG_post :
  [11 * 16][8] -> [16][8] -> [MSG_Size][8] -> [MSG_Size][8] -> Bool
ENC_MSG_post keys tag pt ct =
  leStoreBlocks (counter_mode K2 (0b1 # tUpper, tLower) M) == ct
  where
  K2 = aesKeysFromBytes keys
  M  = leLoadBlocks pt
  _ # tUpper # tLower = leLoad tag





// -----------------------------------------------------------------------------
// -- Debug
vpsllq : [128] -> [128] -> [128]
vpsllq amt x = join [ w << amt | w <- split`{each=64} x ]

vpshufb : [128] -> [128] -> [128]
vpshufb i x = join [ sel ix | ix <- split`{each=8} i ]
  where src  = split`{each=8} x
        sel ix = if ix @ 0 then 0 else src ! (drop`{4} ix)


// -----------------------------------------------------------------------------

aesWithKeys : [11 * 16][8] -> [128] -> [128]
aesWithKeys ks pt = aes (aesKeysFromBytes ks) pt

aesKeysFromBytes : [11 * 16][8] -> KeySchedule
aesKeysFromBytes ks = (k1,kRest,kLast)
  where [k1] # kRest # [kLast] = [ aesStateFromBytes m | m <- split ks ]

aesKeyToBytes : KeySchedule -> [11 * 16][8]
aesKeyToBytes (k1,kRest,kLast) =
  aesStateToBytes k1 # join [ aesStateToBytes x | x <- kRest ] # aesStateToBytes kLast

leLoadBlocks : {n} (fin n) => [n][8] -> [n /^ 16][128]
leLoadBlocks bytes = leLoadArray (bytes # zero)

leStoreBlocks : {n} (fin n) => [n /^ 16][128] -> [n][8]
leStoreBlocks arr = take (leStoreArray arr)

