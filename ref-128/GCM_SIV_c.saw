
// From GCM_SIV_c.c
// Takes about 10 mins on my computer.
AES_128_Key_Expansion <-
  proof
    skipping "AES_128_Key_Expansion"
    c_code
    "AES_128_Key_Expansion"
    []
    false
    do {
      (userkey, val_userkey) <- allocArrayIn "user" 16 i8;
      ks                     <- allocArrayOut "ks" 44 i32;
                                // 11 rounds, at 4 * 32 each
      crucible_execute_func [ userkey, ks ];
      pointsTo ks {{ flatSchedule (expand_key (join val_userkey)) }};
    }
    abc;


// Takes about 9 hours on my computer.
AES_128_Encrypt <-
  proof
    skipping "AES_128_Encrypt"
    c_code
    "AES_128_Encrypt"
    [ emulated_aesenc_row_shifting
    , emulated_aesenc_substitute_bytes
    ]
    false
    do {
      out          <- allocArrayOut "out" 4 i32;
      (in_,val_in) <- allocArrayIn "in"   4 i32;
      (ks,val_ks)  <- allocArrayIn "ks"  44 i32;
      crucible_execute_func [ out, in_, ks ];
      pointsTo out {{ withState (encrypt (unflatShedule val_ks)) val_in }};
    }
    abc;


let {{

from64 : [2][64] -> [128]
from64 [x,y]= y # x

to64 : [128] -> [2][64]
to64 (x # y) = [y,x]

from64s : {n} (fin n) => [2*n][64] -> [n][128]
from64s xs = [ from64 arr | arr <- split xs ]

}};

gfmul_int <-
  proof
    skipping "gfmul_int"
    c_code
    "gfmul_int"
    [vclmul_emulator]
    false
    do {
      (a,val_a) <- allocArrayIn "a" 2 i64;
      (b,val_b) <- allocArrayIn "b" 2 i64;
      // We only every call this with the first and last argument aliased,
      // which is why we just prove this case.
      crucible_execute_func [ a, b, a ];
      pointsTo a {{ to64 (dot (from64 val_a) (from64 val_b)) }};
    }
    rme;


let provePOLYVAL n =
  proof
    skipping (str_concat "POLYVAL, input size = " (show n))
    c_code
    "POLYVAL"
    [ vclmul_emulator, gfmul_int ]
    false
    do {
      (input,val_input)   <- allocArrayIn "input" n  i64;
      (H,val_H)           <- allocArrayIn "H"     2  i64;
      (result,val_result) <- allocArrayIn "result" 2 i64;
      crucible_execute_func [ input, H, crucible_term {{ 8 * `n : [64] }}
                                      , result ];
      pointsTo result {{ to64 (polyvalFrom (from64 val_H)
                                           (from64s val_input)
                                           (from64 val_result)) }};
    }
    abc;


let msg_size_bytes = 24;
let aad_size_bytes = 36;

let {{
type bytesToBlocks x = (8 * x) /^ 128
}};

polyval_msg <- provePOLYVAL (eval_size {| 2 * bytesToBlocks msg_size_bytes |} );
polyval_msg <- provePOLYVAL (eval_size {| 2 * bytesToBlocks aad_size_bytes |} );
polyval_len <- provePOLYVAL 2;


AES_128_CTR <-
  proof
    proving "AES_128_CTR"
    c_code
    "AES_128_CTR"
    [ AES_128_Encrypt ]
    false
    do {
      out            <- allocArrayOut "out" msg_size_bytes i8;
      (in', val_in') <- allocArrayIn  "in"  msg_size_bytes i8;
      (CTR, val_CTR) <- allocArrayIn  "CTR" 4              i32;
      let len = crucible_term {{ `msg_size_bytes : [32] }};
      (ks, val_ks)   <- allocArrayIn "ks"  44 i32;
      crucible_execute_func [out,in',CTR, len, ks];
      pointsTo out
        {{ split`{msg_size_bytes,8} (byteSwap
                      (unblockify (counter_mode ksch (upper,lower) msg))
                      where
                      msg   = blockify (join val_in')
                      lower = val_CTR @ 0
                      upper = (val_CTR @ 3) # (val_CTR @ 2) # (val_CTR @ 1)
                      ksch  = unflatShedule val_ks)
        }};
    }
    abc;




/*
GCM_SIV_ENC_2_Keys <-
  skipping "GCM_SIV_ENC_2_Keys" (
  crucible_llvm_verify
    c_code
    "GCM_SIV_ENC_2_Keys"
    [ AES_128_Key_Expansion
    , AES_128_Encrypt
    , polyval_len
    , polyval_aad
    , polyval_msg
    ]
    false
    do {
      CT            <- crucible_alloc (llvm_array msg_size_bytes i8);
      TAG           <- crucible_alloc (llvm_array 16             i8);
      (K1,val_K1)   <- allocArray "K1"            16             i8;
      (N,val_N)     <- allocArray "N"             12             i8;
      (AAD,val_AAD) <- allocArray "AAD"           aad_size_bytes i8;
      (MSG,val_MSG) <- allocArray "MSG"           msg_size_bytes i8;
      crucible_execute_func [ CT, TAG, K1, N, AAD, MSG
                            , crucible_term  aad_size_bytes
                            , crucible_term  msg_size_bytes ];

      // XXX: Add post condition
    }
    abc
);
*/

